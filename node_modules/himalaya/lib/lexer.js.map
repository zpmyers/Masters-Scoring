{"version":3,"sources":["lexer.js"],"names":["lexer","lex","lexText","lexComment","lexTag","lexTagName","lexTagAttributes","lexSkipTag","str","options","state","cursor","tokens","len","length","isText","charAt","isComment","tagName","safeTag","toLowerCase","childlessTags","textEnd","indexOf","type","content","slice","push","commentEnd","secondChar","close","firstChar","start","char","isTagChar","end","quote","wordBegin","words","isQuoteEnd","isTagEnd","isWordEnd","isQuoteStart","wLen","i","word","isNotPair","secondWord","newWord","thirdWord","index","nextTag","tagState","name","safeTagName","openTag","closeTag"],"mappings":"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","file":"lexer.js","sourcesContent":["import {\n  startsWith,\n  endsWith,\n  stringIncludes,\n  arrayIncludes\n} from './compat'\n\nexport default function lexer (str, options) {\n  const state = {str, options, cursor: 0, tokens: []}\n  lex(state)\n  return state.tokens\n}\n\nexport function lex (state) {\n  const {str} = state\n  const len = str.length\n  while (state.cursor < len) {\n    const isText = str.charAt(state.cursor) !== '<'\n    if (isText) {\n      lexText(state)\n      continue\n    }\n\n    const isComment = startsWith(str, '!--', state.cursor + 1)\n    if (isComment) {\n      lexComment(state)\n      continue\n    }\n\n    const tagName = lexTag(state)\n    if (tagName) {\n      const safeTag = tagName.toLowerCase()\n      const {childlessTags} = state.options\n      if (arrayIncludes(childlessTags, safeTag)) {\n        lexSkipTag(tagName, state)\n      }\n    }\n  }\n}\n\nexport function lexText (state) {\n  const {str, cursor} = state\n  const textEnd = str.indexOf('<', cursor)\n  const type = 'text'\n  if (textEnd === -1) {\n    // there is only text left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  if (textEnd === cursor) return\n\n  const content = str.slice(cursor, textEnd)\n  state.cursor = textEnd\n  state.tokens.push({type, content})\n}\n\nexport function lexComment (state) {\n  state.cursor += 4 // \"<!--\".length\n  const {str, cursor} = state\n  const commentEnd = str.indexOf('-->', cursor)\n  const type = 'comment'\n  if (commentEnd === -1) {\n    // there is only the comment left\n    const content = str.slice(cursor)\n    state.cursor = str.length\n    state.tokens.push({type, content})\n    return\n  }\n\n  const content = str.slice(cursor, commentEnd)\n  state.cursor = commentEnd + 3 // \"-->\".length\n  state.tokens.push({type, content})\n}\n\nexport function lexTag (state) {\n  const {str} = state\n  {\n    const secondChar = str.charAt(state.cursor + 1)\n    const close = secondChar === '/'\n    state.tokens.push({type: 'tag-start', close})\n    state.cursor += close ? 2 : 1\n  }\n  const tagName = lexTagName(state)\n  lexTagAttributes(state)\n  {\n    const firstChar = str.charAt(state.cursor)\n    const close = firstChar === '/'\n    state.tokens.push({type: 'tag-end', close})\n    state.cursor += close ? 2 : 1\n  }\n  return tagName\n}\n\nexport function lexTagName (state) {\n  const {str, cursor} = state\n  const len = str.length\n  let start = cursor\n  while (start < len) {\n    const char = str.charAt(start)\n    const isTagChar = !(char === ' ' || char === '/' || char === '>')\n    if (isTagChar) break\n    start++\n  }\n\n  let end = start + 1\n  while (end < len) {\n    const char = str.charAt(end)\n    const isTagChar = !(char === ' ' || char === '/' || char === '>')\n    if (!isTagChar) break\n    end++\n  }\n\n  state.cursor = end\n  const tagName = str.slice(start, end)\n  state.tokens.push({type: 'tag', content: tagName})\n  return tagName\n}\n\nexport function lexTagAttributes (state) {\n  const {str, tokens} = state\n  let cursor = state.cursor\n  let quote = null // null, single-, or double-quote\n  let wordBegin = cursor // index of word start\n  const words = [] // \"key\", \"key=value\", \"key='value'\", etc\n  const len = str.length\n  while (cursor < len) {\n    const char = str.charAt(cursor)\n    if (quote) {\n      const isQuoteEnd = char === quote\n      if (isQuoteEnd) {\n        quote = null\n      }\n      cursor++\n      continue\n    }\n\n    const isTagEnd = char === '/' || char === '>'\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      break\n    }\n\n    const isWordEnd = char === ' '\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      wordBegin = cursor + 1\n      cursor++\n      continue\n    }\n\n    const isQuoteStart = char === '\\'' || char === '\"'\n    if (isQuoteStart) {\n      quote = char\n      cursor++\n      continue\n    }\n\n    cursor++\n  }\n  state.cursor = cursor\n\n  const wLen = words.length\n  const type = 'attribute'\n  for (let i = 0; i < wLen; i++) {\n    const word = words[i]\n    if (!(word && word.length)) continue\n    const isNotPair = word.indexOf('=') === -1\n    if (isNotPair) {\n      const secondWord = words[i + 1]\n      if (secondWord && startsWith(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          const newWord = word + secondWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n        const thirdWord = words[i + 2]\n        i += 1\n        if (thirdWord) {\n          const newWord = word + '=' + thirdWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n      }\n    }\n    if (endsWith(word, '=')) {\n      const secondWord = words[i + 1]\n      if (secondWord && !stringIncludes(secondWord, '=')) {\n        const newWord = word + secondWord\n        tokens.push({type, content: newWord})\n        i += 1\n        continue\n      }\n\n      const newWord = word.slice(0, -1)\n      tokens.push({type, content: newWord})\n      continue\n    }\n\n    tokens.push({type, content: word})\n  }\n}\n\nexport function lexSkipTag (tagName, state) {\n  const {str, cursor, tokens} = state\n  const len = str.length\n  let index = cursor\n  while (index < len) {\n    const nextTag = str.indexOf('</', index)\n    if (nextTag === -1) {\n      lexText(state)\n      break\n    }\n\n    const tagState = {str, cursor: nextTag + 2, tokens: []}\n    const name = lexTagName(tagState)\n    const safeTagName = tagName.toLowerCase()\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.cursor\n      continue\n    }\n\n    const content = str.slice(cursor, nextTag)\n    tokens.push({type: 'text', content})\n    const openTag = {type: 'tag-start', close: true}\n    const closeTag = {type: 'tag-end', close: false}\n    lexTagAttributes(tagState)\n    tokens.push(openTag, ...tagState.tokens, closeTag)\n    state.cursor = tagState.cursor + 1\n    break\n  }\n}\n"]}