{"version":3,"sources":["parser.js"],"names":["parser","parse","tokens","options","root","tagName","children","state","cursor","stack","nodes","length","len","token","type","push","tagToken","content","toLowerCase","close","item","pop","endToken","closingTags","currentIndex","slice","previousIndex","attributes","attrToken","hasChildren","voidTags","innerState"],"mappings":"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","file":"parser.js","sourcesContent":["import {arrayIncludes} from './compat'\n\nexport default function parser (tokens, options) {\n  const root = {tagName: null, children: []}\n  const state = {tokens, options, cursor: 0, stack: [root]}\n  parse(state)\n  return root.children\n}\n\nexport function parse (state) {\n  const {tokens, options} = state\n  let {stack} = state\n  let nodes = stack[stack.length - 1].children\n  const len = tokens.length\n  let {cursor} = state\n  while (cursor < len) {\n    const token = tokens[cursor]\n    if (token.type !== 'tag-start') {\n      nodes.push(token)\n      cursor++\n      continue\n    }\n\n    const tagToken = tokens[++cursor]\n    cursor++\n    const tagName = tagToken.content.toLowerCase()\n    if (token.close) {\n      let item\n      while ((item = stack.pop())) {\n        if (tagName === item.tagName) break\n      }\n      while (cursor < len) {\n        const endToken = tokens[cursor]\n        if (endToken.type !== 'tag-end') break\n        cursor++\n      }\n      break\n    }\n\n    if (arrayIncludes(options.closingTags, tagName)) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      let currentIndex = stack.length - 1\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex)\n          const previousIndex = currentIndex - 1\n          nodes = stack[previousIndex].children\n          break\n        }\n        currentIndex = currentIndex - 1\n      }\n    }\n\n    let attributes = []\n    let attrToken\n    while (cursor < len) {\n      attrToken = tokens[cursor]\n      if (attrToken.type === 'tag-end') break\n      attributes.push(attrToken.content)\n      cursor++\n    }\n\n    cursor++\n    const children = []\n    nodes.push({\n      type: 'element',\n      tagName: tagToken.content,\n      attributes,\n      children\n    })\n\n    const hasChildren = !(attrToken.close || arrayIncludes(options.voidTags, tagName))\n    if (hasChildren) {\n      stack.push({tagName, children})\n      const innerState = {tokens, options, cursor, stack}\n      parse(innerState)\n      cursor = innerState.cursor\n    }\n  }\n  state.cursor = cursor\n}\n"]}